### **üöÄ MongoDB Performance Optimization Tips**  

MongoDB is a powerful NoSQL database, but performance optimization is key for handling large-scale applications efficiently. Here are some best practices:  

---

## **1Ô∏è‚É£ Indexing for Faster Queries**  
‚úÖ **Use Indexes**: MongoDB scans all documents if no index exists. Create indexes to speed up searches.  
```sh
db.users.createIndex({ email: 1 })  // Index on email field
```
‚úÖ **Check Index Usage**:  
```sh
db.users.explain("executionStats").find({ email: "test@example.com" })
```
‚úÖ **Use Compound Indexes** (For multiple fields)  
```sh
db.users.createIndex({ name: 1, email: 1 })
```
‚úÖ **Avoid Too Many Indexes**: Indexes consume RAM. Keep only necessary indexes.

---

## **2Ô∏è‚É£ Optimize Query Performance**  
‚úÖ **Project Only Required Fields**: Fetch only required fields instead of whole documents.  
```js
db.users.find({}, { name: 1, email: 1, _id: 0 })  // Excludes `_id`
```
‚úÖ **Use `$exists` and `$type` Wisely**: These can slow down queries.  
‚úÖ **Prefer `$in` Instead of Multiple `$or` Queries**:  
```js
db.users.find({ status: { $in: ["active", "pending"] } })
```
‚úÖ **Use Covered Queries**: Queries should only request indexed fields to avoid document scans.  

---

## **3Ô∏è‚É£ Schema Design & Data Modeling**  
‚úÖ **Embed vs. Reference Strategy**:  
- **Embed** when data is frequently accessed together (faster reads).  
- **Reference** when related data is large or updated frequently (reduces duplication).  

**Example: Embedded Document (Faster Reads)**  
```js
{
  name: "John",
  orders: [
    { item: "Laptop", price: 1200 },
    { item: "Mouse", price: 30 }
  ]
}
```
  
**Example: Reference Document (Less Duplication)**  
```js
{
  name: "John",
  orderIds: [ObjectId("order1"), ObjectId("order2")]
}
```

‚úÖ **Use the Right Data Types**: Avoid storing numbers as strings.  

---

## **4Ô∏è‚É£ Query Execution Plan & Profiling**  
‚úÖ **Analyze Queries**:  
```sh
db.collection.explain("executionStats").find({ field: "value" })
```
‚úÖ **Enable Profiling**:  
```sh
db.setProfilingLevel(2)  // Logs all slow queries
```
Check slow queries:  
```sh
db.system.profile.find().sort({ millis: -1 })
```

---

## **5Ô∏è‚É£ Sharding & Scaling**  
‚úÖ **Use Sharding for Large Databases** (Distributes data across multiple servers).  
‚úÖ **Choose a Good Shard Key**: A poor shard key can cause performance issues.  

```sh
sh.shardCollection("mydb.users", { email: "hashed" })
```
‚úÖ **Use Replication for High Availability**  
```sh
rs.initiate()
```

---

## **6Ô∏è‚É£ Connection Pooling & Caching**  
‚úÖ **Use Connection Pooling** in your application to reuse existing connections.  
‚úÖ **Enable Caching** using Redis or Memory caching for frequent queries.  

Example in **Node.js (Mongoose)**:  
```js
const options = { useNewUrlParser: true, useUnifiedTopology: true, poolSize: 10 };
mongoose.connect(MONGO_URI, options);
```

---

## **7Ô∏è‚É£ Avoid Unnecessary Writes**  
‚úÖ **Use `$set` Instead of Rewriting Whole Documents**  
```js
db.users.updateOne({ _id: ObjectId("id") }, { $set: { status: "active" } })
```
‚úÖ **Use Bulk Operations for Large Inserts/Updates**  
```js
db.users.bulkWrite([
  { insertOne: { document: { name: "Alice", email: "alice@test.com" } } },
  { updateOne: { filter: { name: "Bob" }, update: { $set: { email: "bob@test.com" } } } }
])
```

---

## **8Ô∏è‚É£ Optimize Aggregation Pipelines**  
‚úÖ **Use `$match` Early** (Filter as soon as possible).  
‚úÖ **Use `$project` to Reduce Fields**  
‚úÖ **Use `$limit` & `$skip` for Pagination**  

Example Optimized Aggregation Pipeline:  
```js
db.users.aggregate([
  { $match: { age: { $gte: 18 } } },  // Filtering first
  { $project: { name: 1, email: 1, _id: 0 } }, // Select specific fields
  { $sort: { name: 1 } },  // Sorting
  { $limit: 10 }  // Limiting records
])
```

---

## **9Ô∏è‚É£ Optimize Large Collections with TTL Index**  
‚úÖ **Use TTL (Time-To-Live) Index to Auto-Delete Old Records**  
```sh
db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 }) // Deletes after 1 hour
```

---

## **üîü Security Best Practices**  
‚úÖ **Disable Default Bindings** (Don't expose MongoDB to the public)  
```sh
mongod --bind_ip 127.0.0.1
```
‚úÖ **Enable Authentication**  
```sh
db.createUser({ user: "admin", pwd: "securepassword", roles: ["root"] })
```
‚úÖ **Use Environment Variables for Credentials** (Never hardcode DB passwords)  
```sh
MONGO_URI=mongodb+srv://username:password@cluster.mongodb.net/dbname
```

---

### **üéØ Conclusion**  
‚úÖ **Indexing** speeds up queries üöÄ  
‚úÖ **Optimize schema design** for efficient data storage üìÇ  
‚úÖ **Use connection pooling & caching** for better performance üíæ  
‚úÖ **Sharding & replication** scale your database üì°  

Would you like help with **query optimization or specific use cases**?